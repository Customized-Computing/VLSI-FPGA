# 实验2

## 简介

在本次实验中，你将设计一个布局算法，输出模块的坐标。使得整个芯片设计的总线长最小。<br>
为降低问题难度，我们把问题限制在FPGA的布局问题上（对比ASIC的布局问题，FPGA相对来说解空间更小）。

* 实现你的算法，但**暂时不提交**代码。（大作业时统一收三次实验代码）
* **提交**实验报告说明你是如何做的，实验报告应该包含以下内容：
  * <mark>学号+姓名</mark>（有同学实验报告文件不按照要求提交，导致脚本没识别到，这次注意）
  * 算法逻辑和实现思路。**（这部分不要超过2页，挑重点的说）**
    * 例如你采用的算法是模拟退火还是其他算法？
    * 你是如何设计算法的？
    * 你是如何处理约束的？
    * 你的算法有无特别之处、创新之处？
  * 你的算法运行结果表格，报告每一个数据集的布线长度。
  * 实验总结。说明你的方法存在的优点和缺点，下一步改进方向是什么？
  * <mark>非必要，报告中不包含实验代码。实验代码和截图不计入总页数。</mark>

## 代码说明

为了降低同学们非核心算法的代码量，助教为各位同学提供了一个[初始代码](https://github.com/Customized-Computing/VLSI-FPGA/tree/main/lab2)，你只需要实现其中的布局算法。

初始代码包括Arch，Net，Instance基本类。你需要在`Solution.cpp`中实现你的算法，然后在`main.cpp`中调用你的算法。

* `main.cpp`：主可执行文件，需要两个命令行参数，一个是benchmark的文件路径，另一个是输出文件路径。
* `Solution.cpp`：算法实现类，有一个`readBenchMarkFile`函数，用于读取benchmark文件，有一个`outputSolution`函数，输出你的结果到文件。
* `Arch.cpp`：FPGA的布局资源类。你可以利用内置函数实现芯片资源访问和移动。
* `Object.cpp`：Instance类和Net类实现。Instance是同学们需要进行移动和操作的类。

> 注意Object.cpp的Instance类和Arch.cpp的Block类之间没有联动。<br>也就是说，假设Block A有Instance b布局，现在要移动到Block C。仅修改Instance b的坐标信息，当前Block A中存放的Instance指针不会改变，仍然指向Instance b，Block C中存放的Instance指针仍然为NULL。<br>你需要自己实现Instance和Block的联动。
>
> 另外需要注意的是，每个Block仅存放1个Instance。这一点由`Arch.h`的宏定义`MAX_BLOCK_CAPACITY`决定。

### 测试集

下载链接：[校内链接](http://172.18.233.211:5244/pd/VLSI/dataset/placement/lab2_generate_benchmark.zip?signature=898749ea406db33bde30feb5eb3286e0b817fa9804da81a2888a60f738994dd9ae079f3aa895548d889523fff97fb56fc7c5c69bafbdc023210996c07f3eb982)和[校外链接](https://github.com/Customized-Computing/VLSI-FPGA/releases/download/lab2/lab2_generate_benchmark.zip)

数据集大小如下图所示

| 数据集名称 | 元件数量 |
| --- | --- |
| small.txt | ~80 |
| med1.txt | ~320 |
| med2.txt | ~360 |
| lg1.txt | ~720 |
| lg2.txt | ~810 |
| xl.txt | ~1280 |
| huge.txt | ~2000 |

### 程序运行方法

1. 手动编译运行

```bash
g++ -std=c++14 -o main main.cpp Arch.cpp Global.cpp Object.cpp Solution.cpp
./main ./benchmark/small_benchmark.txt ./output/small_placement.txt
```

2. 使用`makefile`脚本编译运行（需要Linux环境）：

```bash
make all
```

3. 兼容Vscode的`F5运行并调试`功能：

操作方式类似于实验1，在`.vscode/launch.json`中配置`args`参数，使其适应lab2程序的参数需求即可。

> 注意：代码直接运行会输出较多文字且提示存在非常多错误，原因是代码没有实现具体的布局算法，只是提供了一些基本的函数和类。<br>元件实例在初始化时预设坐标为(-1,-1)不在布局资源图内，因此会输出很多错误。

## 输入文件格式

> 如果你对助教们写的数据读取模块性能不够满意，或者不支持你的奇思妙想，你可以自己写一个数据读取模块。

本节内容面向需要自行编写数据读取模块的同学。

第一行包括两个数字，第一个数字代表FPGA布局资源的宽度(x维度)，第二个数字代表FPGA布局资源的高度(y维度)。<br>
紧随其后是行数不确定的固定模块信息和行数不确定的网表信息。固定模块信息和网表信息之间使用一个空行分割。

固定模块信息：
每一行包括三个数字，第一个数字是模块的编号，第二个数字是模块x坐标，第三个数字是模块y坐标。
<mark>要求布局算法不允许移动这些模块的位置。</mark><br>
**例如**：模块1就限制布局位置为(8,0)，模块2就限制布局位置为(9,6)。

网表信息：
每一行包括的数字个数不唯一。
第一个数字代表模块的编号，之后的每个数字都代表相连的线网(net)的编号。<br>
**例如**：模块1仅和线网83相连，模块2和线网82相连，而模块27与线网1、25、34、93、95、96、98相连。

```text
10 10
0 4 0
1 8 0
2 9 6
3 0 5
4 0 4
5 6 0
6 1 0
7 3 9
8 7 9
9 9 3
10 0 2
11 0 6
12 9 4
13 0 8
14 3 0
15 0 7
16 5 0
17 9 2
18 7 0
19 0 3
20 4 9
21 9 7
22 2 9
23 5 9
24 8 9

0 104
1 83
2 82
3 44
4 14
5 20
6 37
...
27 1 25 34 93 95 96 98
```

## 输出文件格式

要求布局算法的输出是一个文件，命名格式为`benchmark_name_placement.txt`，例如`small_placement.txt`。

输出文件每一行包括三个数字，第一个数字是模块的编号，第二个数字是模块x坐标，第三个数字是模块y坐标。

```text
0 4 0
1 8 0
2 9 6
3 0 5
4 0 4
...
```

## 如何提交

实验报告命名格式为**学号\_姓名\_第二次作业.pdf**。

发送到助教邮箱（可在主页找到）<br>
<mark>截止日期：2025年5月22日23时59分</mark><br>
后期会统计已经收到作业的同学，并发在群里。如果上传作业后有更新，请命名为V2、V3……，并在助教统计作业上交情况时注意是否收到最新版本。

